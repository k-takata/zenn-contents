---
title: "NiMH充電器&測定器の作成 (その2)"
emoji: "🔋"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["電子工作", "avr", "pcbway"]
published: false
---

## 概要

本記事は、以下の記事の続きとなります。

* [NiMH充電器&測定器の作成 (その1)](https://zenn.dev/k_takata/articles/nimh-charger-tester-1.md)

今回は、その1で作成した基板上で動くソフトウェアの作成について記載します。

作成する「NiMH充電器&測定器」の機能や特徴を再掲します。

* 「[USB NiMH ゆっくり充電器](https://github.com/k-takata/PCB_USB_NiMH_Charger/tree/batt-4)」を踏襲し、USB Type-Cで電源供給。
* 「USB NiMH ゆっくり充電器」を踏襲および以下の効果を期待し、0.1C程度でゆっくりと充電。
  1. 電池の劣化を抑える。
  2. 他の充電器では充電できない程度に劣化の進んだ電池でも充電できるようにする。(大電流を必要としない用途ではまだ使える可能性があるため。)
* 単3または単4を1本充放電し、容量や内部抵抗を測定。
* 充放電状況をLEDで表示。詳細情報はOLEDディスプレイに表示。

作成に当たっては、その1に引き続き、以下の書籍を参考にしました。

1. [トランジスタ技術SPECIAL No.135 Liイオン/鉛/NiMH蓄電池の充電&電源技術](https://shop.cqpub.co.jp/hanbai/books/46/46751.html)   
   「第4章　研究！ ニッケル水素蓄電池の耐久テスト」 下間 憲行著
2. [トランジスタ技術SPECIAL No.170 教科書付き 小型バッテリ電源回路](https://www.cqpub.co.jp/trs/trsp170.htm)   
   「Appendix 1　充放電回数の限界…サイクル耐久特性の実測」 下間 憲行著
3. [電池応用ハンドブック](https://www.cqpub.co.jp/hanbai/books/34/34461.htm)


## 開発環境

### Arduino IDE

開発にはArduino IDE 2.3.6を使用しました。

ボードパッケージには[DxCore](https://github.com/SpenceKonde/DxCore)を使用します。[DxCore Installation](https://github.com/SpenceKonde/DxCore/blob/master/Installation.md)にしたがってボードマネージャ経由でインストールを行います。


### 書き込みツール

[SerialUPDI](https://github.com/SpenceKonde/AVR-Guidance/blob/master/UPDI/jtag2updi.md)にしたがって、UPDI書き込みツールを用意します。

適当なUSBシリアルアダプターと、470Ω抵抗、ショットキーバリアダイオードがあれば簡単に書き込みツールが作成できます。


## ソフトウェア作成方針(当初案)

当初は以下のような機能を実現するつもりで開発を始めました。

* 単3と単4のどちらの電池が挿入されているかを自動検出する。
* 充電電流は0.1Cを基本とし、単3は200mA、単4は70mAとする。
* 「USB NiMH ゆっくり充電器」やその元となった[いたわりNiCd充電器 キット](https://akizukidenshi.com/img/contents/kairo/%E3%83%87%E3%83%BC%E3%82%BF/%E5%85%85%E9%9B%BB%E5%99%A8%E9%96%A2%E4%BF%82/H001%E3%81%84%E3%81%9F%E3%82%8F%E3%82%8ANiCd_.pdf)と同様に、充電時の電圧を監視し、指定の電圧に達した時点で終了とする。
* 充電時の温度も測定し、充電電圧に約-3mV/Kの温度係数を含める。
* 安全のため、タイマーでの充電停止も備える。
* 安全のため、温度監視での充電停止も備える。
* 内部抵抗の大きくなってしまった電池でも充電電圧を正しく測定できるようにするため、電圧測定時には一時的に充電を停止し、間欠的に充電を行う。
* 充電中の電圧と、充電一時停止中の電圧を比較することで、電池の内部抵抗を計算し、表示する。

ただ、実際に開発を進めてみると、当初の想定とは異なることがいろいろ出てきました。ここからは、実際に開発を進めた手順をなぞりながら各機能を説明していきます。


## 要素機能の実装

### 電源電圧の測定機能

今回作成した回路では、電源電圧が様々な電圧の基準となっています。そこでまずは電源電圧を測定する機能を作成します。

```C++
#define PIN_VREFA   PIN_PD7

// TP1 (VREFA, TL431) の実際の電圧。理想的には 2.495 V
const float vrefa_calib = 2.483;

// TL431 の ADC 値を使い Vdd 電圧を算出する
float getVddVolt()
{
  int vrefa = analogReadEnh(PIN_VREFA, 15);
  float vdd = vrefa_calib * 32768.0 / vrefa;
  return vdd;
}
```

AVRのADC機能は、デフォルトでは電源電圧を基準とした値を返します。基準電圧を他のものに変更することもできますが、今回の回路では、0Vから電源電圧までの範囲で電圧測定を行いたいので、必然的に基準は電源電圧とすることになります。

基準電圧ICのTL431をPD7ピン(VREFAピン)に入力し、そのADC値を取得し、そこから電源電圧を逆算しています。
TL431の出力電圧は、理想的には2.495Vですが、実際には多少の誤差があるので、実測値を使って計算を行います。

Arduinoにおいて、ADC値を取得する関数は、`analogRead()` です。デフォルトの精度は8bitですが、`analogReadResolution()` を使うことで12bit精度にできます。しかし、今回はより高精度に測定を行うため、DxCoreの拡張関数である `analogReadEnh()` を使うことで15bitオーバーサンプリングを行うことにしました。


### 電池電圧の測定機能

BT1(単3)あるいはBT2(単4)の電圧を取得する関数です。
電池のADC値を取得し、電源電圧を掛けることで実際の電圧を算出します。
15bitオーバーサンプリングを行って正確な値を取得するか、オーバーサンプリングを行わずに短時間で値を取得するかを選択できます。

```C++
// BT1 あるいは BT2 の電圧を取得
float getBtVolt(int bt, bool hires=true)
{
  if (hires) {
    int vbt = analogReadEnh(PIN_VBT1 + bt - 1, 15);
    return vbt * getVddVolt() / 32768.0;
  }
  else {
    int vbt = analogRead(PIN_VBT1 + bt - 1);
    return vbt * getVddVolt() / 4096.0;
  }
}
```


### 電池の挿入状態の検出機能

今回の回路では、充電回路・放電回路・BT1(単3)・BT2(単4)の間にブリッジダイオードを配置することで、BT1とBT2の電圧を別々に取得できるようにしたつもりでいました。

しかし実際に試してみたところ、BT1、BT2のどちらか一方だけを挿入した状態で充電を続けていると、BT1とBT2の測定値が同じになってしまい、どちらに電池が挿入されているか判別できなくなってしまう問題が発生しました。

おそらくはブリッジダイオードの漏れ電流によって、BT1とBT2の電圧が同じになってしまったと思われます。

そこで対策として、充放電を一時停止し、コンデンサーの電荷を放電してからBT1, BT2の電圧を測定することで、電池の挿入状態を検出することにしました。

```C++
#define BT_HIGH_THRESHOLD 1.8
#define BT_LOW_THRESHOLD  0.5

// 電池の接続状態をチェック
//  戻り値:
//   -1: エラー。BT1またはBT2が1.8Vを超えている
//    0: 電池未接続
//    1: BT1が接続
//    2: BT2が接続
//    3: BT1とBT2の両方が接続
int checkBtConnection()
{
  chgctl(false);    // 充電停止
  disctl(false);    // 放電停止

  // VBT1,2 ピンに接続されたコンデンサーを放電 (20ms)
  pinMode(PIN_VBT1, OUTPUT);
  pinMode(PIN_VBT2, OUTPUT);
  digitalWrite(PIN_VBT1, LOW);
  digitalWrite(PIN_VBT2, LOW);
  delay(20);

  // VBT1,2 ピンを入力に戻して1ms待つ
  pinMode(PIN_VBT1, INPUT);
  pinMode(PIN_VBT2, INPUT);
  delay(1);

  // BT1, BT2の電圧を取得
  float vbt1 = getBtVolt(1, false);
  float vbt2 = getBtVolt(2, false);

  int ret = 0;
  if (vbt1 > BT_HIGH_THRESHOLD || vbt2 > BT_HIGH_THRESHOLD) {
    ret = -1;   // どちらかが1.8Vを超えていればエラー
  }
  else {
    if (vbt1 > BT_LOW_THRESHOLD) {
      ret |= 1; // BT1が0.5Vを超えている
    }
    if (vbt2 > BT_LOW_THRESHOLD) {
      ret |= 2; // BT2が0.5Vを超えている
    }
  }
  Serial.printf(F("checkBtConnection: %.3f V, %.3f V, ret=%d\n"), vbt1, vbt2, ret);
  return ret;
}
```

充放電を一時停止し、ピンを出力に切り替えてコンデンサーの電荷を放電し、20ms待ってピンを入力に切り替え、1ms待ってから電圧を測定します。

電圧が1.8Vを超えていればエラーとし、0.5Vを超えていれば接続されていると判定します。


### 充放電電流の設定機能

PWMを使ってオペアンプに入力する電圧を生成し、それによって充放電電流を設定します。

`analogWrite()` は8bit精度のため精度が足りないので、自前でPWM制御を行い10bit精度とすることにしました。

`takeOverTCA0()` を呼ぶことで、TCA0の制御権を取得できます。


#### PWM値の設定

PWM値を設定することで充放電電流を設定する機能を用意します。

PWM値は10bitなので、値が0~1023の範囲に収まるようにクリップします。
クリップした値を `TCA0.SINGLE.CMPx` レジスタに設定すれば完了です。

```C++
#define PWM_MAX_VAL 1023  // PWM値の最大値(10bit)

// PWM値をクリップする
int clipPwmVal(int val)
{
  if (val < 0) {
    val = 0;
  }
  else if (val > PWM_MAX_VAL) {
    val = PWM_MAX_VAL;
  }
  return val;
}

// PIN_PWMCHG(充電ピン)のPWM値を設定
void setPwmChg(int val)
{
  val = clipPwmVal(val);
  TCA0.SINGLE.CMP1 = val;
}

// PIN_PWMDIS(放電ピン)のPWM値を設定
void setPwmDis(int val)
{
  val = clipPwmVal(val);
  TCA0.SINGLE.CMP2 = val;
}
```

#### mA単位での電流の設定

続いて、より使いやすくするため、mA単位で電流を設定できる機能を用意します。

充放電用負荷抵抗の値と現在の電源電圧からPWM値を算出し、前述の関数で設定します。

```C++
// 充電用負荷抵抗: 10 Ω
const float r_charge = 10.0;
// 放電用負荷抵抗: 1 Ω
const float r_discharge = 1.0;

// mA単位で充電電流を設定
// 精度: Vdd / (PWM_MAX_VAL + 1) / r_charge = 5.0 / 1024 / 10 = 0.488 mA
void setChgCurrent(float ma)
{
  float vdd = getVddVolt();
  float v = vdd - ma * r_charge / 1000.0;
  int val = int(round(PWM_MAX_VAL * v / vdd));
  setPwmChg(val);
}

// mA単位で放電電流を設定
// 精度: Vdd / (PWM_MAX_VAL + 1) / r_discharge = 5.0 / 1024 / 1.0 = 4.88 mA
void setDisCurrent(float ma)
{
  float vdd = getVddVolt();
  float v = ma * r_discharge / 1000.0;
  int val = int(round(PWM_MAX_VAL * v / vdd));
  setPwmDis(val);
}
```

### 充放電電流の取得機能

当初は、前述の設定機能で設定した電流が流れるものと想定していましたが、実際に試してみたところ、設定した電流と実際の電流が大きく食い違う場合がありました。
特に、電池の内部抵抗が大きい状態で、放電電流を大きく設定した場合に、放電電流が設定値を大きく下回る場合がありました。

そこで、PCBに2か所改造を行い、充放電電流を測定できるようにしました。

```C++
// mA単位での充電電流を取得
float getChgCurrent()
{
  float vdd = getVddVolt();
  return vdd * (32767 - analogReadEnh(PIN_VCHG, 15)) / 32768.0 / r_charge * 1000.0;
}

// mA単位での放電電流を取得
float getDisCurrent()
{
  float vdd = getVddVolt();
  return (vdd * analogReadEnh(PIN_VDIS, 15) / 32768.0) / r_discharge * 1000.0;
}
```

充放電用負荷抵抗の値と現在の電源電圧から電流値を算出しています。


### 温度測定機能

今回の回路では、温度センサーとしてMCP9700BT-E/TTを2個使用しています。

このセンサーは、0℃でのオフセットが500mV、温度係数は10.0 mV/℃ですので、出力電圧を $V$ [V]、温度を $T$ [℃] とすると次のようになります。

$$ V = 0.5 + 0.01 T $$

これを変形すると次のようになります。

$$ T = 100 V - 50 $$

```C++
// ボードの温度を取得
float getTemp1()
{
  int vtemp = analogReadEnh(PIN_VTEMP1, 14);
  return vtemp * getVddVolt() / 40.96 / 4 - 50.0;
}

// 電池近傍の温度を取得
float getTemp2()
{
  int vtemp = analogReadEnh(PIN_VTEMP2, 14);
  return vtemp * getVddVolt() / 40.96 / 4 - 50.0;
}
```

### 要素機能のまとめ

ここまででNiMH充電器&測定器の要素機能の実装がほぼ完了しました。ここからはこれらを組み合わせて充放電機能を実装していきます。


## 充電機能

電池を挿入し、Chgボタンを押すと充電が開始され、Chgランプが点灯します。
充電中にChgボタンあるいはDisボタンを押すと、充電が停止します。
充電停止中にChgボタンを押すと充電が再開します。

Modeボタンを押すと表示が切り替わります。(後述)


### 間欠充電

今回の回路は定電流充電を基本としていますが、前述の電池挿入状態の検出機能を組み合わせることにより、図らずも半ば自動的に、内部抵抗が高い電池のための間欠充電が実装されました。

以下の処理を1秒ごとに繰り返しています。

1. `checkBtConnection()` で電池挿入状態の検出を行う。
   - 充電を停止して20ms待つ。
   - 1ms待って、電池の挿入状態をチェックする。
2. 電圧が安定するのを待つためにさらに10ms待って、充電一時停止中の電圧(v\_idle)を測定する。
3. 充電を再開する。
4. 電圧が安定するのを待つために20ms待って、充電中の電圧(v\_chg)を測定する。
5. 次の1秒サイクルまで充電を継続する。

これにより、1秒の内、約30msは充電一時停止となり、残りの約970msで実際に充電を行っていることになります。

また、v\_idleとv\_chgから電池の内部抵抗を算出することができます。

ところで、間欠充電方式ですが、実はかつて特許が取られていました。(失効済み)



### タイマーによる充電停止

0.1Cでの定電流充電の場合、およそ10時間で充電が完了することになります。

実際には充電時の損失があるためもう少し長い時間が掛かり、電池容量のばらつきも考慮し、1.4倍の14時間で充電を停止するようにしています。


### 終止電圧監視による充電停止

「USB NiMH ゆっくり充電器」やその元となった「いたわりNiCd充電器 キット」と同様に、充電時の電圧を監視し、指定の電圧に達した時点で終了とする機能を実装しました。また、ボードの温度を測定し、-3mV/Kの補正を加えることにしました。

実際にいくつかの電池で充電を行ってみたところ、電池によりかなり終止電圧が変わることが判明しました。(1.49V ~ 1.51V)

より確実な充電停止を行うようにするため、次の方法を実装してみることにしました。


### -ΔV検出による充電停止

次に実装することにしたのは、急速充電器で一般的に使用されている-ΔV検出による充電停止です。

一般に、充電電流が多いと-ΔVの下がり幅が大きくなり、充電電流が少ないと下がり幅は小さくなると言われています。今回はとりあえず4mVを閾値とし、以下のようなアルゴリズムを実装しました。

1. 充電電圧が1.38V以上になった時点で-ΔV検出処理を開始。
2. 10秒ごとの単純移動平均(SMA)を算出し、最大値から4mVの電圧降下が20回検出されたら充電停止。

試してみたところ、一部の電池では-ΔVが検出され、正常に充電が停止しました。その際、電池の温度は40℃程度とほんのり発熱していました。

*グラフ*

しかし、別のかなり劣化した電池では-ΔVが検出されず、ダラダラと電圧が上がり続け、最終的には14時間タイマーで充電が停止しました。

*グラフ*

より確実な充電停止を行うようにするため、さらに次の方法を実装してみることにしました。


### ピーク検出による充電停止

[バッテリ充電器の新しい展開](https://www.analog.com/jp/resources/design-notes/new-developments-in-battery-chargers.html)を見たところ、次のような記載がありました。

> NiCdの急速充電は、ΔV/Δtが負になったときに停止します。NiMH電池では、端子電圧がピーク(ΔV/Δtがゼロ)になったときに急速充電を停止してください。

また、前述の特許にも、NiMH電池では-ΔV検出では過充電になってしまうとの記載がありました。

ということで、ピーク検出による充電停止を実装してみることにしました。今回は以下のような条件で実装してみました。

1. 充電電圧が1.38V以上になった時点で-ΔV検出処理と同時にピーク検出処理を開始。
2. 10分間充電電圧が1mVも上昇しなければ充電停止。

試してみたところ、-ΔVが検出されなかった電池でも電圧の上昇停止が検出され、正しく充電が停止されました。電池の発熱も、-ΔV検出に比べて抑えられていました。

*グラフ*


### 温度監視による充電停止 (未実装)

今回の回路は0.1C充電を基本としているため、電池への負担はそれほど高くなく、電池の発熱もあまりありません。

ただ、安全性を追求するなら電池の温度を監視し、異常発熱していれば充電を停止するのがよいと思われます。
また、単位時間の温度上昇(ΔT/Δt)が一定値を超えることで充電完了を検知する方法もあるので、そのような機能を実装するのも面白そうです。

ただ今回は、電池近傍の温度センサーを壊してしまったため、これらの実装は行っていません。


## 放電機能

電池の放電を行って、電池の容量や内部抵抗を測定することができます。

電池を挿入し、Disボタンを押すと放電が開始され、Disランプが点灯します。
充電中にChgボタンあるいはDisボタンを押すと、放電が停止します。
放電停止中にDisボタンを押すと放電が再開します。

Modeボタンを押すと表示が切り替わります。(後述)


### 間欠放電

放電についても充電と同じように間欠処理を行っています。以下の処理を1秒ごとに繰り返しています。

1. `checkBtConnection()` で電池挿入状態の検出を行う。
   - 放電を停止して20ms待つ。
   - 1ms待って、電池の挿入状態をチェックする。
2. 電圧が安定するのを待つためにさらに10ms待って、放電一時停止中の電圧(v\_idle)を測定する。
3. 放電を再開する。
4. 電圧が安定するのを待つために100ms待って、放電中の電圧(v\_dis)を測定する。
5. 次の1秒サイクルまで放電を継続する。

これにより、1秒の内、約30msは放電一時停止となり、残りの約970msで実際に放電を行っていることになります。
間欠充電とは、4. の待ち時間が20msから100msに延びている点が異なります。

また、v\_idleとv\_disから電池の内部抵抗を算出することができます。

放電の終了はv\_idleで監視を行い、これが放電終止電圧(1.0V)未満になったら放電を停止します。

v\_disが放電終止電圧を下回っていても、v\_idleが放電終止電圧に達していない限り放電を続けるので、電池の内部抵抗が無視できるような低消費電力機器でどれだけの容量を使用できるかが分かります。

*グラフ*


## その他の機能

### 表示機能

Modeボタンで以下の表示を順に切り替えられるようになっています。

1. 詳細表示
2. 簡易表示
3. グラフ表示
4. 設定画面 (充放電停止中のみ)


#### 詳細表示

#### 簡易表示

#### グラフ表示

充放電電圧をグラフ表示します。


### 設定機能

以下の値を設定できます。

* 充電電流
  - 0.2C
  - 0.1C
  - 0.05C
* 放電電流
  - 0.5C
  - 0.1C
  - 0.05C
* 充電終止電圧
* 放電終止電圧

Chg/↑ボタンとDis/↓ボタンでカーソルを移動し、Mode/OKボタンで選択します。

設定値はEEPROMに保存されます。


### シリアル通信機能

シリアル通信端子から、充放電時のログを出力できます。

ホストPCから "send" と送信すると、ログがCSV形式で返ってきます。


## ソースコード

完成したソースコードは
...
に置いています。


## まとめ
